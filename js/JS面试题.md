## JS面试题

### 1.正则表达式

```javascript
\d 匹配数字 \D 匹配非数字 \w 匹配数字字母下划线 \W 匹配非数字字母下划线
\n 匹配一个换行符 \s 匹配任何不可⻅字符包括空格、制表符、换⻚符等等 \S 匹配任何可⻅字符 ^ 匹配输入字行首 $匹配输入行尾 *(0到多次)匹配前面的子表达式任意次
+(1到多) 匹配前面的子表达式一次或多次(大于等于1次)
?(0或1)匹配前面的子表达式零次或一次
{n}n是一个非负整数，匹配确定的n次
{n,}n是一个非负整数。至少匹配n次
```

### 2.Ajax

我对ajax的理解是，它是一个浏览器异步通讯的方法，通过直接js脚本向服务器发起http请求，然后服务器返回数据，更新网页的相应部分，不会刷新整个页面的一种方法。

```javascript
// 1.创建ajax对象
var xhr = new XMLHttpRequest();
// 2.配置 Ajax请求地址
xhr.open('get','index.html',true);
// 3.发起请求
xhr.send(null); 
// 4.监听请求，接收响应
xhr.onreadyStateChange = function(){
  if(xhr.readyState === 4 && xhr.status === 200 || xhr.status === 304) {
    console.log(xhr.responseXML)
  }
}
```

### 3.js 延迟加载的方式

js的加载、解析和执行会阻塞页面的渲染过程，因此我们希望js脚本能够尽可能的延迟加载，提高页面的渲染速度。

我了解到的几种方法如下：

1. 将js脚本放到文档的底部，使js脚本尽可能的在最后来加载执行。
2. js脚本添加defer属性，这个属性会让脚本的加载与文档的进行同步解析，然后解析完成后再执行这个js脚本，这样就不会造成页面渲染的阻塞。如果设置了多个defer属性，按规范来说，最后执行是按顺序执行的。
3. js脚本添加async属性，这个属性会让脚本进行异步加载，它不会阻塞页面的解析过程，但是脚本一旦加载完成，就会立即执行，如果这个时候文档还没有解析完成的话，同样是会造成阻塞的。如果设置多个async属性，脚本执行的顺序是不可预测的。
4. 动态创建DOM标签的方式，对文档加载事件进行监听，当文档加载完成后，然后动态创建script标签来引入js脚本。

### 4.模块化开发的理解

我对模块化开发的理解如下：

一个模块就是实现一个特定功能的一组方法。在最开始的时候，js只实现一些简单的功能，所以没有模块化的概念，但是后来随着程序越来越复杂，代码的模块化开发就变得越来越重要。

由于函数具有独立作用域的特点，最原始的方法是使用函数来做模块，几个函数作为一个模块，但是这种方式容易造成全局变量污染，并且模块之间没有联系。

后来提出了对象写法，通过将函数作为一个对象的方法来实现，这样就解决了直接使用函数作为模块的一些缺点，但是这种方法会暴露所有的模块成员，外部代码是可以修改内部属性的值。

现在最常用的是立即执行函数的写法，通过利用闭包来实现模块化私有作用域，同时不会对全局作用域造成污染。

### 5.js 的几种模块规范

js中现在有比较成熟的四种模块加载方案：

一、CommonJS方案，它通过require来引入模块，通过module.exports定义模块的输出接口。这种模块解决方案主要是用于服务端的，因为它是使用同步的方式来引入模块，所以不适合用于浏览器端，因为浏览器端是需要进行网络请求的，可能会造成阻塞，使用异步加载方式更适合。

二、AMD模块，这种方案采用的是异步加载的方式来引入模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数中，等到加载完成后再执行回调函数。require.js实现了AMD规范。

三、CMD模块，这种方案和AMD方案都是为了解决异步模块加载的问题，sea.js实现了这CMD的规范。它和require.js的区别就是在于模块定义时和对依赖模块的执行时机处理不同。

四、ES6提出的方案，使用import和export的形式来导入导出模块。

### 6.AMD**和**CMD规范的区别?

它们主要区别有两方面：

1. 在模块定义时对模块依赖处理不同。AMD推崇依赖前置，在模块定义的时候就要声明其依赖的模块。而CMD推崇就近依赖，只有在用到这个模块的时候再去require。
2. 对依赖模块的执行时机不同。首先AMD和CMD对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD在依赖模块加载完成时就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而CMD在依赖模块加载完成后并不执行，等到下载完成后，所有依赖都加载好了，进入回调函数执行require，这样就保证了模块的执行顺序和我们书写的顺序一致。

### 7.ES6**模块与**CommonJS 模块区别？

1. CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用。
2. CommonJS模块是运行时加载，ES6模块是编译时输出接口。CommonJS模块就是对象，即输入时先加载整个模块，输出一个对象，然后再这个对象上读取方法，这个加载称为"运行时加载"，而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

### 8.requireJS的核心原理

require.js的核心原理就是通过动态创建script标签来异步引入模块，然后对每个脚本的load事件进行监听，如果每个脚本都加载完成了，再调用回调函数。

### 9.js的运行机制（事件循环）

首先js是**单线程**运行的，在代码执行的时候，通过不同的函数执行上下文压入**执行栈**来保证代码的有序执行。

在执行同步代码块时候，如果遇到了异步事件，js引擎并不会一直等到其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。

所有的任务可以分为两种，一种是**同步任务**，另一种是**异步任务**。

同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务。

异步任务：不进入主线程的任务，而是进入任务队列（task queue）的任务，只有等待主线程任务执行完毕，任务队列开始通知主线程，请求执行任务，该任务才会进入到主线程执行。

当同步事件执行完毕后，再将异步事件对应的回调加入到当前执行栈中不同的另一个任务队列中等待执行。

任务队列可以分为**宏任务**和**微任务**，当执行栈中的事件执行完毕，js引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后，再去判断宏任务队列中的任务是否需要执行。

事件循环机制：

1. 所有的同步任务都在主线程上执行，形成一个执行栈。
2. 主线程之外，还存在一个任务队列，只要异步任务有了结果，就会在任务队列中放置一个事件。
3. 一旦执行栈中所有的同步任务执行完毕，js引擎就会开始读取任务队列，看看里面有哪些事件，如果存在异步任务，于是结束等待状态，调入执行栈中开始执行。
4. 主线程不断重复上面三步。

### 10.arguments 对象

```javascript
arguments对象是函数中传递参数值的集合。它是一个类似数组的对象，因为它有一个length属性，可以通过使用数组索引表示法arguments[1]来访问单个值，但是它没有数组中的内置方法,如：forEach、reduce、filter和map。

我们可以使用Array.prototype.slice将arguments对象转换成一个数组

Array.prototype.slice.call(arguments)
```

### 11.垃圾回收机制的两种方法

现在各大浏览器通常用采用的垃圾回收有两种方法:标记清除、引用计数。

1. 标记清除  这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上 讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环 境时，则将其标记为“离开环境”。  垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的 变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些 变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

2. 引用计数  另一种不太常⻅的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量 并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个 值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内 存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。

### 12.内存泄漏有哪些？

1. 意外的全局变量
2. 被遗忘的定时器或回调函数
3. 脱离DOM的引用
4. 闭包

> 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。 
>
> 第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量 会被一直留在内存中，而无法被回收。 
>
> 第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它 也无法被回收。
>
> 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。

### 13.ES2015(ES6)新特性有哪些？

1. 块级作用域

2. 类(class)

3. 箭头函数
4. 模板字符串
5. 对象解构
6. Promise
7. 模块化export、import
8. Symbol
9. Proxy代理
10. Set/Map
11. 函数默认参数
12. rest
13. 扩展运算符

### 14.ES2016(ES7)新特性

1. 求幂运算符(**)

2. Array.prototype.includes()方法，数组原型的方法,查找一个数值是否在数组中，只能判断一些简单类型的数据，对于复杂类型的数据无法判断。 该方法接受两个参数，分别是查询的数据和初始的查询索引值。

### 15.ES2017(ES8)新特性

1. async/await
2. Object.values() / Object.keys() / Object.entries() / Object.getOwnPropertyDescriptors()

### 16.var、let、const的区别？

1. var 声明的变量会挂载到window上，let和const不会
2. var声明的变量存在变量提升，let和const不存在
3. let和const声明会形成块级作用域
4. 同一作用域下let和const不能重复声明同一个变量，而var可以
5. const声明的变量是一个常量，且必须赋值，不能赋值为null,声明后不能被修改，如果声明的是复合类型数据，可以修改其属性。
6. let和const存在暂时性死区,var不存在

### 17.箭头函数

1. 箭头函数表达式比函数表达式更简洁
2. 箭头函数没有自己的this。箭头函数内的this指向的是父级的this
3. 箭头函数适用于一些匿名函数的地方，并且不能用作构造函数
4. 当只有一个表达式或值需要返回，不需要return语句
5. 当箭头函数没有参数时，可以省略括号
6. 箭头函数不能访问arguments对象，所以调用第一个getArgs函数会抛出一个错误。 相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。

### 18.高阶函数

首先高阶函数肯定是函数，不同的是输入的参数和返回的值这两项中的一项必须是函数才能叫高阶函数。

这个问题在回答的时候可以稍微拓展一下，介绍一下常用的的高阶函数。

 比如:map、flatMap、filter、reduce、fold。

### 19.new操作符的过程

1. 在内存中创建一个空对象
2. 将空对象的__proto__指向到函数的prototype上

3. 将新创建的对象作为this的上下文
4. 如果该函数没有返回对象，则默认返回this

### 20.什么是回调函数？回调函数有什么缺点？

回调函数是一个匿名函数，它作为一个参数传递给其他代码，其作用是在需要的时候方便调用这段代码，可以让异步代码同步执行。

缺点：容易写出回调地狱

### 21.instanceof的原理

 instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链上是不是能找到此类型的原型。

1. 首先获取类型的原型
2. 获取对象的原型
3. 然后一直循环判断对象的原型是否等于类型的原型，知道对象原型为null，因为原型链最终指向为null

```javascript
function myInstanceof(left,right) {
  let prototype = right.prototype;
  left = left.prototype;
  while(true) {
    if(left === null || left === undefined) {
      return false;
    }
    if(prototype === left) {
      return true;
    }
    left = left.__proto__;
  }
}
```

### 22.设计模式

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。

1. 单例模式
2. 工厂模式
3. 观察者模式
4. 代理模式
5. 策略模式
6. 迭代器模式

单例模式(Singleton Pattern) ：单例模式中Class的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。

工厂模式：工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。 使用场景:如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话， 那么工厂模式是一个理想的选择。

### 23.js的基本数据类型、值是如何存储的？

 JavaScript一共有8种数据类型

7种基本数据类型: Undefined、Null、Boolean、Number、String、Symbol(es6新增，表示独一无二的值)和BigInt(es10新增)

1种引用数据类型 Object(Object本质上是由一组无序的名值对组成的)。 里面包含 function、Array、Date等。

JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。

原始数据类型:直接存储在栈(stack)中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 

引用数据类型:同时存储在栈(stack)和堆(heap)中，占据空间大、大小不固定。引用数据类型在栈中存储了指针（地址），该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

### 24.js的数据类型的转换

 在 JS 中类型转换只有三种情况，分别是:

1. 转换为布尔值(调用Boolean()方法) 

2. 转换为数字(调用Number()、parseInt()和parseFloat()方法) 

3. 转换为字符串(调用.toString()或者String()方法)

### 25.{}**和**[]**的**valueOf**和**toString的结果

```javascript
 {} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]" 
 [] 的 valueOf 结果为 [] ，toString 的结果为 ""
```

### 26.js作用域和作用域链

什么是js的作用域：

作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量(标识符)进行变量查找。

作用域又分为全局作用域和局部作用域，作用域决定了这些变量的可访问性，函数内部定义的变量从函数外部是不访问的。

作用域链：

当查找变量时，首先从当前上下文的变量中查找，如果没有找到，就会从父级执行上下文的变量对象查找，一直找到全局上下文的变量对象，也就是全局对象，这样由多个执行上下文的变量对象构成的链表叫做作用域链。

### 27.**对**this**、**call**、**apply**和**bind的理解

1. 在浏览器中，全局范围内的this指向window对象
2. 在函数中，this永远指向最后调用它的对象
3. 在构造函数中，this的指向new出来的那个新对象
4. call、apply、bind中的this被强绑定在指定的那个对象上
5. 箭头函数中this比较特殊，箭头函数this指向的是父级的this，不是调用时的this，并且箭头函数this指向是静态的，在声明的时候就已经确定下来
6. apply、call都是为了解决this指向。作用是相同的，只是传参的方式不同，除了第一个参数外，call第二个参数接收的是参数列表，apply第二个参数接受的是参数数组。
7. bind和apply、call作用相同，只是它返回的是一个函数。

### 28.**什么是** DOM **和** BOM？

DOM指的是文档对象模型，这个对象主要定义了处理网⻚内容的方法和接口。

BOM指的是浏览器对象模型，这个对象主要定义了与浏览器进行交互的方法和接口。

BOM的核心是 window，而 window 对象具有双重⻆色，它既是通过 js 访问浏览器窗口的一个接口， 又是一个 G全局对象。 这意味着在网⻚中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。

window 对象含有 location 对象、navigator对象、screen对象等子对象， 并且 DOM 的最根本的对象 document ，document对象也是 window 对象的子对象。

### 29.**原型**、原型链

原型：js规定，每个函数都有一个prototype对象属性，指向另一个对象。prototype就是调用构造函数所创建的那个实例对象的原型。

原型链：当访问一个对象的某个属性时，首先会从该对象的自己属性中查找，如果没有找到，就会从它的__proto__隐式原型上查找，即它的构造函数的原型prototype，如果还没有找到，就会去构造函数的prototype的__proto__中查找，这样一层一层的往上就会形成一条链式结构，我们称为原型链。

### 30.prototype**、**proto**、**constructor三者的关系

![watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzgyNDY2NA==,size_16,color_FFFFFF,t_70](images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzgyNDY2NA==,size_16,color_FFFFFF,t_70.png)

### 31.跨域出现的原因以及解决方法

原因：是因为浏览器的同源策略所造成的。

哪些情况下会产生跨域？协议/域名/端口号不同

解决办法：

1. 后端代理

   后端是不存在跨域的，利用后端开放权限去获取接口数据。

2. jsonp

   原理是利用了script标签src属性不受同源策略的影响。通过动态创建script标签，将事先写好的函数名传给服务端，服务端配合进行操作返回数据。

3. 前端反向代理

   使用proxy webpack配置

   ```javascript
   "proxy": {
     "/index.php": {
      	"target": "http://qinqin.net",
       "changeOrigin": true
     }
   }
   ```

4. cors解决跨域（后端）

### 32.闭包原理/优点/缺点/使用场景

闭包的作用：

1. 可以在外部访问函数内部的变量

2. 让函数的局部变量可以一直保存下去

闭包的原理：

闭包是定义在函数内部的函数，闭包是将函数内部和函数外部连接起来的一座桥梁。它打破了作用域链的规则，能够读取其他函数内部变量的函数。

优点：

1. 使用闭包不会污染全局环境
2. 方便模块化开发
3. 减少形参的个数，延长了形参的生命周期

缺点：使用不当会造成内存泄漏

使用场景：

1. 通过循环给页面多个dom节点绑定事件
2. 封装私有变量（计数器）
3. 延长局部变量的生命周期
4. 高阶组件
5. 函数防抖与节流

### 

